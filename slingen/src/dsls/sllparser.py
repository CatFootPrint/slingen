# 2017-07-12 23:29:11.526707
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# CAVEAT UTILITOR
# This file was automatically generated by Grako.
#    https://bitbucket.org/apalala/grako/
# Any changes you make to it will be overwritten the
# next time the file is generated.
#

from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import *  # noqa
from grako.exceptions import *  # noqa


__version__ = '17.193.21.29.11'


class sigmallParser(Parser):
    def __init__(self, whitespace=None, **kwargs):
        super(sigmallParser, self).__init__(whitespace=whitespace, **kwargs)

    @rule_def
    def _program_(self):

        def block0():
            self._statement_()
            self.ast.add_list('stmt', self.last_node)
        self._positive_closure(block0)

        self._check_eof()

    @rule_def
    def _statement_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._llfor_()
                with self._option():
                    self._llif_()
                with self._option():
                    self._equation_()
                self._error('no available options')
        self._token(';')

    @rule_def
    def _llfor_(self):
        self._token('For')
        self._cut()
        self._preprocs_()
        self._looptop_()
        self.ast['looptop'] = self.last_node
        self._token('{')

        def block1():
            self._statement_()
            self.ast.add_list('body', self.last_node)
        self._positive_closure(block1)

        self._token('}')

    @rule_def
    def _looptop_(self):
        self._token('[')
        self._id_()
        self.ast['idx'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['lb'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['ub'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['s'] = self.last_node
        self._token(']')

    @rule_def
    def _llif_(self):
        self._token('If')
        self._cut()
        self._preprocs_()
        self._guard_()
        self.ast['guard'] = self.last_node
        self._token('{')

        def block1():
            self._statement_()
            self.ast.add_list('then', self.last_node)
        self._positive_closure(block1)

        self._token('}')

    @rule_def
    def _guard_(self):
        self._token('[')
        self._condexpr_()
        self.ast['ce'] = self.last_node
        self._token(']')

    @rule_def
    def _equation_(self):
        self._lhs_()
        self.ast['lhs'] = self.last_node
        self._token('=')
        self._rhs_()
        self.ast['rhs'] = self.last_node

    @rule_def
    def _lhs_(self):
        self._id_()
        self.ast['id'] = self.last_node

    @rule_def
    def _rhs_(self):
        self._expr_()
        self.ast['@'] = self.last_node

    @rule_def
    def _expr_(self):
        self._term_()
        self.ast.add_list('term', self.last_node)

        def block1():
            self._add_()
            self.ast.add_list('op', self.last_node)
            self._cut()
            self._term_()
            self.ast.add_list('term', self.last_node)
        self._closure(block1)

    @rule_def
    def _term_(self):
        self._factor_()
        self.ast.add_list('factor', self.last_node)

        def block1():
            self._md_()
            self.ast.add_list('fop', self.last_node)
            self._cut()
            self._factor_()
            self.ast.add_list('factor', self.last_node)
        self._closure(block1)

    @rule_def
    def _factor_(self):
        with self._choice():
            with self._option():
                self._scatter_()
                self.ast['@'] = self.last_node
            with self._option():
                self._scatteracc_()
                self.ast['@'] = self.last_node
            with self._option():
                self._planefactor_()
                self.ast['@'] = self.last_node
            self._error('no available options')

    @rule_def
    def _scatter_(self):
        self._token('[')
        self._imf_()
        self.ast['simf'] = self.last_node
        self._token(',')
        self._imf_()
        self.ast['simf'] = self.last_node
        self._token(']')
        self._factor_()
        self.ast['factor'] = self.last_node

    @rule_def
    def _scatteracc_(self):
        self._token('$[')
        self._imf_()
        self.ast['saimf'] = self.last_node
        self._token(',')
        self._imf_()
        self.ast['saimf'] = self.last_node
        self._token(']')
        self._factor_()
        self.ast['factor'] = self.last_node

    @rule_def
    def _planefactor_(self):
        with self._optional():
            self._add_()
            self.ast['sign'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._sum_()
                    self.ast['factor'] = self.last_node
                with self._option():
                    self._trans_()
                    self.ast['factor'] = self.last_node
                with self._option():
                    self._sqrt_()
                    self.ast['factor'] = self.last_node
                with self._option():
                    self._subexpr_()
                    self.ast['factor'] = self.last_node
                with self._option():
                    self._id_()
                    self.ast['id'] = self.last_node
                with self._option():
                    self._constnum_()
                    self.ast['const'] = self.last_node
                self._error('no available options')
        self._preprocg_()
        self._gather_()
        self.ast['gather'] = self.last_node

    @rule_def
    def _gather_(self):
        with self._choice():
            with self._option():
                self._token('[')
                self._imf_()
                self.ast['gimf'] = self.last_node
                self._token(',')
                self._imf_()
                self.ast['gimf'] = self.last_node
                self._token(']')
                self._gather_()
                self.ast['gather'] = self.last_node
            with self._option():
                pass
            self._error('no available options')

    @rule_def
    def _preprocg_(self):
        pass

    @rule_def
    def _preprocs_(self):
        pass

    @rule_def
    def _sum_(self):
        self._token('Sum')
        self._cut()
        self._token('[')
        self._id_()
        self.ast['idx'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['lb'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['ub'] = self.last_node
        self._token(';')
        self._numexpr_()
        self.ast['s'] = self.last_node
        self._token(']')
        self._token('{')
        self._expr_()
        self.ast['body'] = self.last_node
        self._token('}')

    @rule_def
    def _trans_(self):
        self._token('trans')
        self._token('(')
        self._cut()
        self._expr_()
        self.ast['@'] = self.last_node
        self._token(')')

    @rule_def
    def _sqrt_(self):
        self._token('sqrt')
        self._token('(')
        self._cut()
        self._expr_()
        self.ast['@'] = self.last_node
        self._token(')')

    @rule_def
    def _subexpr_(self):
        self._token('(')
        self._expr_()
        self.ast['par'] = self.last_node
        self._token(')')
        with self._optional():
            self._token('[')
            self._condexpr_()
            self.ast['guard'] = self.last_node
            self._token(']')

    @rule_def
    def _imf_(self):
        with self._choice():
            with self._option():
                self._iimf_()
                self.ast['@'] = self.last_node
            with self._option():
                self._genimf_()
                self.ast['@'] = self.last_node
            with self._option():
                self._himf_()
                self.ast['@'] = self.last_node
            self._error('no available options')

    @rule_def
    def _genimf_(self):
        self._token('f(')
        self._cut()
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(')')

    @rule_def
    def _himf_(self):
        self._token('h(')
        self._cut()
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['params'] = self.last_node
        with self._optional():
            self._token(',')
            self._numexpr_()
            self.ast['params'] = self.last_node
        self._token(')')

    @rule_def
    def _iimf_(self):
        self._token('fI(')
        self._cut()
        self._numexpr_()
        self.ast['params'] = self.last_node
        self._token(')')

    @rule_def
    def _condexpr_(self):
        self._condterm_()
        self.ast.add_list('condterm', self.last_node)

        def block1():
            self._token('||')
            self._cut()
            self._condterm_()
            self.ast.add_list('condterm', self.last_node)
        self._closure(block1)

    @rule_def
    def _condterm_(self):
        self._condfactor_()
        self.ast.add_list('condfactor', self.last_node)

        def block1():
            self._token('&&')
            self._cut()
            self._condfactor_()
            self.ast.add_list('condfactor', self.last_node)
        self._closure(block1)

    @rule_def
    def _condfactor_(self):
        with self._optional():
            self._token('(')
        self._numexpr_()
        self.ast['condl'] = self.last_node
        self._condsym_()
        self.ast['condsym'] = self.last_node
        self._numexpr_()
        self.ast['condr'] = self.last_node
        with self._optional():
            self._token(')')

    @rule_def
    def _numexpr_(self):
        with self._optional():
            self._add_()
            self.ast['sign'] = self.last_node
        self._numterm_()
        self.ast.add_list('numterm', self.last_node)

        def block2():
            self._add_()
            self.ast.add_list('op', self.last_node)
            self._cut()
            self._numterm_()
            self.ast.add_list('numterm', self.last_node)
        self._closure(block2)

    @rule_def
    def _numterm_(self):
        self._numfactor_()
        self.ast.add_list('numfactor', self.last_node)

        def block1():
            self._mul_()
            self.ast.add_list('op', self.last_node)
            self._cut()
            self._numfactor_()
            self.ast.add_list('numfactor', self.last_node)
        self._closure(block1)

    @rule_def
    def _numfactor_(self):
        with self._choice():
            with self._option():
                self._mod_()
            with self._option():
                self._floord_()
            with self._option():
                self._ceild_()
            with self._option():
                self._min_()
            with self._option():
                self._max_()
            with self._option():
                self._id_()
                self.ast['id'] = self.last_node
            with self._option():
                self._zint_()
                self.ast['const'] = self.last_node
            with self._option():
                self._numsubexpr_()
            self._error('no available options')

    @rule_def
    def _mod_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('mod(')
                with self._option():
                    self._token('Mod(')
                self._error('expecting one of: mod( Mod(')
        self._cut()
        self._numexpr_()
        self.ast['modl'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['modr'] = self.last_node
        self._token(')')

    @rule_def
    def _floord_(self):
        self._token('floord(')
        self._cut()
        self._numexpr_()
        self.ast['fnum'] = self.last_node
        self._token(',')
        self._int_()
        self.ast['fden'] = self.last_node
        self._token(')')

    @rule_def
    def _numsubexpr_(self):
        self._token('(')
        self._cut()
        self._numexpr_()
        self.ast['numpar'] = self.last_node
        self._token(')')

    @rule_def
    def _ceild_(self):
        self._token('ceild(')
        self._cut()
        self._numexpr_()
        self.ast['cnum'] = self.last_node
        self._token(',')
        self._int_()
        self.ast['cden'] = self.last_node
        self._token(')')

    @rule_def
    def _min_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('min(')
                with self._option():
                    self._token('Min(')
                self._error('expecting one of: min( Min(')
        self._cut()
        self._numexpr_()
        self.ast['minl'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['minr'] = self.last_node
        self._token(')')

    @rule_def
    def _max_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('max(')
                with self._option():
                    self._token('Max(')
                self._error('expecting one of: max( Max(')
        self._cut()
        self._numexpr_()
        self.ast['maxl'] = self.last_node
        self._token(',')
        self._numexpr_()
        self.ast['maxr'] = self.last_node
        self._token(')')

    @rule_def
    def _condsym_(self):
        with self._choice():
            with self._option():
                self._token('==')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('>')
            with self._option():
                self._token('<=')
            with self._option():
                self._token('<')
            with self._option():
                self._token('!=')
            self._error('expecting one of: > >= <= != < ==')

    @rule_def
    def _add_(self):
        self._pattern(r'[\+-]')

    @rule_def
    def _mul_(self):
        self._pattern(r'[\*/]')

    @rule_def
    def _md_(self):
        self._pattern(r'[\\\*/]')

    @rule_def
    def _constnum_(self):
        self._pattern(r'[0-9]+')

    @rule_def
    def _zint_(self):
        with self._choice():
            with self._option():
                self._token('0')
            with self._option():
                self._int_()
            self._error('expecting one of: 0')

    @rule_def
    def _int_(self):
        with self._choice():
            with self._option():
                self._pattern(r'[1-9][0-9]*')
            with self._option():
                self._pattern(r'[A-Za-z]')
            self._error('expecting one of: [A-Za-z] [1-9][0-9]*')

    @rule_def
    def _id_(self):
        self._pattern(r'[A-Za-z][A-Za-z0-9_]*')


class sigmallSemanticParser(CheckSemanticsMixin, sigmallParser):
    pass


class sigmallSemantics(object):
    def program(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def llfor(self, ast):
        return ast

    def looptop(self, ast):
        return ast

    def llif(self, ast):
        return ast

    def guard(self, ast):
        return ast

    def equation(self, ast):
        return ast

    def lhs(self, ast):
        return ast

    def rhs(self, ast):
        return ast

    def expr(self, ast):
        return ast

    def term(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def scatter(self, ast):
        return ast

    def scatteracc(self, ast):
        return ast

    def planefactor(self, ast):
        return ast

    def gather(self, ast):
        return ast

    def preprocg(self, ast):
        return ast

    def preprocs(self, ast):
        return ast

    def sum(self, ast):
        return ast

    def trans(self, ast):
        return ast

    def sqrt(self, ast):
        return ast

    def subexpr(self, ast):
        return ast

    def imf(self, ast):
        return ast

    def genimf(self, ast):
        return ast

    def himf(self, ast):
        return ast

    def iimf(self, ast):
        return ast

    def condexpr(self, ast):
        return ast

    def condterm(self, ast):
        return ast

    def condfactor(self, ast):
        return ast

    def numexpr(self, ast):
        return ast

    def numterm(self, ast):
        return ast

    def numfactor(self, ast):
        return ast

    def mod(self, ast):
        return ast

    def floord(self, ast):
        return ast

    def numsubexpr(self, ast):
        return ast

    def ceild(self, ast):
        return ast

    def min(self, ast):
        return ast

    def max(self, ast):
        return ast

    def condsym(self, ast):
        return ast

    def add(self, ast):
        return ast

    def mul(self, ast):
        return ast

    def md(self, ast):
        return ast

    def constnum(self, ast):
        return ast

    def zint(self, ast):
        return ast

    def int(self, ast):
        return ast

    def id(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = sigmallParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in sigmallParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for sigmall.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace, whitespace=args.whitespace)